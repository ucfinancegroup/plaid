/*
 * Plaid API Endpoints Copy 2
 *
 * A collection of Plaid API endpoints for the `sandbox` environment. Each endpoint request comes with an example request & response. It also contains 'use cases' for each product.   <br /> Before you begin, please set your `client_id` and `secret_key` variables in the Sandbox environment. You can find them in your Plaid [dashboard](https://dashboard.plaid.com/account/keys). Set the variables by clicking on the 'eye' icon in the top-right corner of the screen.
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `automated_deposit_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AutomatedDepositWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_public_tokenfor_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePublicTokenforUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `retrieve_an_items_accounts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveAnItemsAccountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `retrieve_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `rotate_access_token`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RotateAccessTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `simulate_itemloginrequired_sandbox_only`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimulateItemloginrequiredSandboxOnlyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_an_items_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAnItemsWebhookError {
    UnknownValue(serde_json::Value),
}


pub async fn automated_deposit_webhook(configuration: &configuration::Configuration, automated_deposit_webhook_request: crate::models::AutomatedDepositWebhookRequest) -> Result<crate::models::AutomatedDepositWebhookResponse, Error<AutomatedDepositWebhookError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sandbox/item/set_verification_status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&automated_deposit_webhook_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AutomatedDepositWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_public_tokenfor_update(configuration: &configuration::Configuration, create_public_tokenfor_update_request: crate::models::CreatePublicTokenforUpdateRequest) -> Result<crate::models::CreatePublicTokenforUpdateResponse, Error<CreatePublicTokenforUpdateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/item/public_token/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_public_tokenfor_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreatePublicTokenforUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to remove an `Item` using its `access_token`.
pub async fn remove_item(configuration: &configuration::Configuration, remove_item_request: crate::models::RemoveItemRequest) -> Result<crate::models::RemoveItemResponse, Error<RemoveItemError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/item/remove", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&remove_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to retrieve all available `Account`s associated with an `Item`.
pub async fn retrieve_an_items_accounts(configuration: &configuration::Configuration, retrieve_an_items_accounts_request: crate::models::RetrieveAnItemsAccountsRequest) -> Result<crate::models::RetrieveAnItemsAccountsResponse, Error<RetrieveAnItemsAccountsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/accounts/get", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&retrieve_an_items_accounts_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveAnItemsAccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to retrieve information about an `Item`.
pub async fn retrieve_item(configuration: &configuration::Configuration, retrieve_item_request: crate::models::RetrieveItemRequest) -> Result<crate::models::RetrieveItemResponse, Error<RetrieveItemError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/item/get", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&retrieve_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// By default, the `access_token` associated with an `Item` does not expire and should be stored in a persistent, secure manner.   <br /> You can use the POST `/item/access_token/invalidate` endpoint to rotate the `access_token` associated with an `Item`. The endpoint returns a new `access_token` and immediately invalidates the previous `access_token`.
pub async fn rotate_access_token(configuration: &configuration::Configuration, rotate_access_token_request: crate::models::RotateAccessTokenRequest) -> Result<crate::models::RotateAccessTokenResponse, Error<RotateAccessTokenError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/item/access_token/invalidate", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&rotate_access_token_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RotateAccessTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// An `Item` may transition into an error state in response to changes made by the user or financial institution. The most common scenarios are when a user changes their password or when the financial institution changes their multi-factor authentication flow. [Plaid Link](https://plaid.com/docs/api/#updating-items-via-link) makes it easy to restore a user's `Item` to a good state by having them provide updated credentials and MFA information, if needed.   <br /> In the Sandbox, `Item`s transition to an `ITEM_LOGIN_REQUIRED` error state automatically after 30 days. You can also simulate this event via an API request.   <br /> The `/sandbox/item/reset_login` endpoint allows you put an Item in an `ITEM_LOGIN_REQUIRED` error state. You can then use [Plaid Link update mode](https://plaid.com/docs/api/#updating-items-via-link) to restore the `Item` to a good state.   <br /> An `ITEM_LOGIN_REQUIRED` webhook will be fired after a call to this endpoint, if one is associated with the `Item`.
pub async fn simulate_itemloginrequired_sandbox_only(configuration: &configuration::Configuration, simulate_item_login_required_sandbox_only_request: crate::models::SimulateItemLoginRequiredSandboxOnlyRequest) -> Result<crate::models::SimulateItemLoginRequiredSandboxOnlyResponse, Error<SimulateItemloginrequiredSandboxOnlyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sandbox/item/reset_login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&simulate_item_login_required_sandbox_only_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimulateItemloginrequiredSandboxOnlyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to update the webhook url for an `Item`. This request triggers a `WEBHOOK_UPDATE_ACKNOWLEDGED` [webhook](https://plaid.com/docs/api/#item-webhooks).
pub async fn update_an_items_webhook(configuration: &configuration::Configuration, update_an_items_webhook_request: crate::models::UpdateAnItemsWebhookRequest) -> Result<crate::models::UpdateAnItemsWebhookResponse, Error<UpdateAnItemsWebhookError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/item/webhook/update", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_an_items_webhook_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateAnItemsWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}


/*
 * Plaid API Endpoints Copy 2
 *
 * A collection of Plaid API endpoints for the `sandbox` environment. Each endpoint request comes with an example request & response. It also contains 'use cases' for each product.   <br /> Before you begin, please set your `client_id` and `secret_key` variables in the Sandbox environment. You can find them in your Plaid [dashboard](https://dashboard.plaid.com/account/keys). Set the variables by clicking on the 'eye' icon in the top-right corner of the screen.
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_asset_report`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetReportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_audit_copy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAuditCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `refresh_asset_report`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshAssetReportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_asset_report`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAssetReportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_audit_copy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAuditCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `retrievean_asset_report_json`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveanAssetReportJsonError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `retrievean_asset_report_pdf`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveanAssetReportPdfError {
    UnknownValue(serde_json::Value),
}


/// With your desired `access_tokens` in hand, all you need to do to create an Asset Report is to call the `/asset_report/create` endpoint.  When creating an Asset Report, the only required fields are your `client_id`, `secret`, an `array of access_tokens` (one for each Item to be included in the Report), and the number of `days_requested` which determines the duration of transaction history to be included.  `options` is optional!
pub async fn create_asset_report(configuration: &configuration::Configuration, create_asset_report_request: crate::models::CreateAssetReportRequest) -> Result<crate::models::CreateAssetReportExample, Error<CreateAssetReportError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_asset_report_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateAssetReportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Plaid can provide an **Audit Copy** of any Asset Report directly to a participating third party on your behalf.   An Audit Copy contains the same underlying data as the Asset Report. To grant access to an Audit Copy, you’ll create an `audit_copy_token` for it and then pass that token to the third party who needs access. Each third party has its own `auditor_id`, for example `fannie_mae`. You’ll need to create a separate Audit Copy for each third party to whom you want to grant access to the report.
pub async fn create_audit_copy(configuration: &configuration::Configuration, create_audit_copy_request: crate::models::CreateAuditCopyRequest) -> Result<crate::models::CreateAuditCopyExample, Error<CreateAuditCopyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/audit_copy/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_audit_copy_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateAuditCopyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Asset Report based on the old one, but with the most recent data available from the financial institution(s).
pub async fn refresh_asset_report(configuration: &configuration::Configuration, refresh_asset_report_request: crate::models::RefreshAssetReportRequest) -> Result<crate::models::RefreshAssetReportExample, Error<RefreshAssetReportError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/refresh", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&refresh_asset_report_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RefreshAssetReportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The `/asset_report/remove` endpoint allows you to remove an Asset Report. Removing an Asset Report invalidates its `asset_report_token`, meaning you will no longer be able to use it to access report data or create new Audit Copies. Removing an Asset Report does not affect the underlying Items, but does also invalidate any `audit_copy_token`s associated with the Asset Report. In other words, removing an Asset Report also cascade-removes its Audit Copies.
pub async fn remove_asset_report(configuration: &configuration::Configuration, remove_asset_report_request: crate::models::RemoveAssetReportRequest) -> Result<crate::models::RemoveAssetReportExample, Error<RemoveAssetReportError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/remove", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&remove_asset_report_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveAssetReportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The `/asset_report/audit_copy/remove` endpoint allows you to remove an Audit Copy. Removing an Audit Copy invalidates the `audit_copy_token` associated with it, meaning both you and any third parties holding the token will no longer be able to use it to access report data. `Item`s associated with the Asset Report, the Asset Report itself and other Audit Copies of it are not affected and will remain accessible after removing the given Audit Copy.
pub async fn remove_audit_copy(configuration: &configuration::Configuration, remove_audit_copy_request: crate::models::RemoveAuditCopyRequest) -> Result<crate::models::RemoveAuditCopyExample, Error<RemoveAuditCopyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/audit_copy/remove", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&remove_audit_copy_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveAuditCopyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can retrieve your Asset Report in multiple formats (PDF and JSON), determined by the endpoint you call.  JSON: `/asset_report/get`   PDF: `/asset_report/pdf/get`   <br /> Just like retrieving `transaction` data, you need to wait several seconds to retrieve an assets report after you create one. A good practice is to retrieve the data when you are notified that it's ready via webhook.
pub async fn retrievean_asset_report_json(configuration: &configuration::Configuration, retrievean_asset_report_json_request: crate::models::RetrieveanAssetReportJsonRequest) -> Result<crate::models::RetrieveanAssetReportJsoNwithInsights, Error<RetrieveanAssetReportJsonError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/get", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&retrievean_asset_report_json_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveanAssetReportJsonError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can retrieve your Asset Report in multiple formats (PDF and JSON), determined by the endpoint you call.  JSON: `/asset_report/get`   PDF: `/asset_report/pdf/get`   <br /> Just like retrieving `transaction` data, you need to wait several seconds to retrieve an assets report after you create one. A good practice is to retrieve the data when you are notified that it's ready via webhook.
pub async fn retrievean_asset_report_pdf(configuration: &configuration::Configuration, retrievean_asset_report_pdf_request: crate::models::RetrieveanAssetReportPdfRequest) -> Result<(), Error<RetrieveanAssetReportPdfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/asset_report/pdf/get", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&retrievean_asset_report_pdf_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<RetrieveanAssetReportPdfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

